Utils = require 'utils'
Templete = require './javaTemplete'
fs = require 'fs'
mkdirSync = ( require 'vendor/mkdirSync' ).mkdirSync

exports.init = ( options )->
	path = Utils.getJavaDirPath options
	javaName = Utils.getJavaName( options.FUNCTION )
	javapath = path + javaName
	console.log 'path=' + path
	mkdirSync path, 0, ( err )->
		if err
			throw err
		_renderCmd javapath, options
		_renderIService javapath, options
		_renderService javapath, options
		_renderIDomain javapath, options
		_renderDomain javapath, options
		_renderSqlMap javapath, options
		
_renderCmd = ( javapath, options )->
	cmdcontent = Templete.renderCmd( javapath, options )
	fs.writeFile javapath + 'Cmd.java',new Buffer( cmdcontent ),( err )->
		if err
			console.log err
			throw err
		console.log '_renderCmd has finished'

_renderIService = ( javapath, options )->
	iservicecontent = Templete.renderIService( javapath, options )
	fs.writeFile javapath + 'IService.java',new Buffer( iservicecontent ),( err )->
		if err
			throw err
		console.log '_renderIService has finished'
		
_renderService = ( javapath, options )->
	servicecontent = Templete.renderService( javapath, options )
	fs.writeFile javapath + 'Service.java',new Buffer( servicecontent ),( err )->
		if err
			throw err
		console.log '_renderService has finished'
		
_renderIDomain = ( javapath, options )->
	idomaincontent = Templete.renderIDomain( javapath, options )
	fs.writeFile javapath + 'IDomain.java',new Buffer( idomaincontent ),( err )->
		if err
			throw err
		console.log '_renderIDomain has finished'
		
_renderDomain = ( javapath, options )->
	domaincontent = Templete.renderDomain( javapath, options )
	fs.writeFile javapath + 'Domain.java',new Buffer( domaincontent ),( err )->
		if err
			throw err
		console.log '_renderDomain has finished'
		
_renderSqlMap = ( javapath, options )->
	sqlcontent = Templete.renderSqlMap( javapath, options )
	fs.writeFile javapath + 'SqlMap.xml',new Buffer( sqlcontent ),( err )->
		if err
			throw err
		console.log '_renderSqlMap has finished'